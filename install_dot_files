#!/usr/bin/python

import optparse
import hashlib
import os
import platform
import re
import shutil
import subprocess
import sys


dirs = [
    ('bin', None),
    ('.ssh', 0700)
]

# Ensure that the set operation below includes UNKNOWN.
uname_to_arch = {'Darwin': 'OSX', 'Linux': 'LINUX', '':'UNKNOWN'}

archs = set(uname_to_arch.values())

installs = [
  ('dot.bash_aliases', '.bash_aliases'),
  ('dot.tmux.conf', '.tmux.conf', True),
  ('dot.bashrc', '.bashrc'),
  ('dot.gitconfig', '.gitconfig', True),
  ('dot.gitignore_global', '.gitignore_global'),
  ('dot.profile', '.profile'),
  ('dot.screenrc', '.screenrc'),
  ('bin/cleanm', ),
  ('bin/get_prompt', ),
  ('bin/git_fix_precommit', ),
  ('bin/git_sclone', ),
  ('bin/git_start', ),
  ('bin/git_tig_status', ),
  ('bin/git_track', ),
  ('bin/mkpdshgrpfiles.sh', ),
  ('bin/nukem', ),
  ('bin/projtool', ),
  ('dot.ssh/config', '.ssh/config'),
]

removals = [
    ('bin/g', 'bin/g'),
]

home = os.environ['HOME']


def md5_digest(filename):
    with open(filename) as f:
        return hashlib.md5(f.read()).hexdigest()


def targets(args, files):
    allowed = set(args.files)
    for target in files:
        if len(target) == 1:
            target = (target[0], target[0], False)
        if len(target) == 2:
            target = (target[0], target[1], False)
        (source, deployed, translate) = target
        if not is_allowed_file(source, deployed, allowed):
            continue
        deployed_full_path = os.path.join(home, deployed)
        if (source in args.files or
            deployed in args.files or
            deployed_full_path in args.files or
            not args.files):
            yield (source, deployed_full_path, translate)


def completions(args):
    for target in installs:
        if len(target) == 1:
           target = (target[0], target[0])
        print target[0]
        print target[1]
        print os.path.join(home, target[1])


def is_allowed_file(src, dest, files):
    if not files:
        return True
    return (src in files) or (dest in files)


def install(args):
  if os.path.exists(os.path.join(home, '.bash_profile')):
      print >> sys.stderr, ".bash_profile exists. This can cause problems. Maybe you should remove it."

  for (dir, perms) in dirs:
      dir_full_path = os.path.join(home, dir)
      if not os.path.exists(dir_full_path):
          os.mkdir(dir_full_path)
      if not perms is None:
          os.chmod(dir_full_path, perms)
      for (source, deployed, translate) in targets(args, installs):
          if not os.path.exists(source):
              continue
          if translate:
              process_file_for_arch(source, deployed, get_arch())
          else:
              shutil.copy2(source, deployed)
      for (source, deployed, translate) in targets(args, removals):
          if os.path.exists(deployed):
              os.unlink(deployed)


def get_arch():
    return uname_to_arch.get(platform.uname()[0], 'UNKNOWN')


def process_file_for_arch(src, dest, arch):
    with open(src, 'r') as src_file:
        with open(dest, 'w') as dest_file:
            for line in filter_for_arch(src_file, arch):
                dest_file.write(line)


has_arch = re.compile(r'^(%s):' % '|'.join(archs))


def filter_for_arch(lines, arch):
    for line in lines:
        match = has_arch.search(line)
        if match and match.group(1) != arch:
            pass
        elif match:
            yield line[len(match.group(0)):]
        else:
            yield line


def recover(args):
  for (source, deployed, translated) in targets(args, installs):
      if os.path.exists(deployed):
          if  translated:
              if md5_digest(source) != md5_digest(deployed):
                  subprocess.call(['p4merge', deployed, source, source, source])
          else:
              shutil.copy2(deployed, source)


def diff(args):
  for (source, deployed, translate) in targets(args, installs):
    if os.path.exists(source) and not os.path.exists(deployed):
        print "File %s not deployed from %s" % (deployed, source)
    elif not os.path.exists(source) and os.path.exists(deployed):
        print "File %s not recovered from %s" % (source, deployed)
    elif os.path.exists(source) and os.path.exists(deployed):
      if md5_digest(source) != md5_digest(deployed):
        subprocess.call(['p4merge', deployed, source])


parser = optparse.OptionParser(description='install dot files')
parser.add_option('--diff', dest='action', action='store_const',
    const=diff, help='diff deployed and source dot files')
parser.add_option('--install', dest='action', action='store_const',
    const=install, help='install dot files')
parser.add_option('--recover', dest='action', action='store_const',
    const=recover, help='recover dot files from environment')
parser.add_option('--completions', dest='action', action='store_const',
    const=completions, help='show possible file path completions')

if __name__ == '__main__':
    (opts, args) = parser.parse_args()
    if opts.action is None:
        opts.action = diff
    opts.files = args
    opts.action(opts)

