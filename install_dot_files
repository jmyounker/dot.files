#!/usr/bin/python

from contextlib import contextmanager
import optparse
import hashlib
import os
import platform
import re
import shutil
import subprocess
import sys


dirs = [
    ('bin', None),
    ('.ssh', 0700)
]

# Ensure that the set operation below includes UNKNOWN.
uname_to_arch = {'Darwin': 'OSX', 'Linux': 'LINUX', '':'UNKNOWN'}

archs = set(uname_to_arch.values())

installs = [
  ('dot.bash_aliases', '.bash_aliases'),
  ('dot.bashrc', '.bashrc'),
  ('dot.dput.cf', '.dput.cf'),
  ('dot.gitconfig', '.gitconfig', True),
  ('dot.gitignore_global', '.gitignore_global'),
  ('dot.profile', '.profile'),
  ('dot.screenrc', '.screenrc'),
  ('dot.tmux.conf', '.tmux.conf', True),
  ('bin/cleanm', ),
  ('bin/get_prompt', ),
  ('bin/git_fix_precommit', ),
  ('bin/git_sclone', ),
  ('bin/git_start', ),
  ('bin/git_tig_status', ),
  ('bin/git_track', ),
  ('bin/mkpdshgrpfiles.sh', ),
  ('bin/nukem', ),
  ('bin/projtool', ),
  ('bin/retry', ),
  ('dot.ssh/config', '.ssh/config', True),
]

removals = [
    ('bin/g', 'bin/g'),
]

home = os.environ['HOME']


def md5_digest(filename):
    with open(filename) as f:
        return hashlib.md5(f.read()).hexdigest()


def targets(args, files):
    allowed = set(args.files)
    for target in files:
        if len(target) == 1:
            target = (target[0], target[0], False)
        if len(target) == 2:
            target = (target[0], target[1], False)
        (source, deployed, translate) = target
        if not is_allowed_file(source, deployed, allowed):
            continue
        deployed_full_path = os.path.join(home, deployed)
        if (source in args.files or
            deployed in args.files or
            deployed_full_path in args.files or
            not args.files):
            yield (source, deployed_full_path, translate)


def completions(args):
    for target in installs:
        if len(target) == 1:
           target = (target[0], target[0])
        print target[0]
        print target[1]
        print os.path.join(home, target[1])


def is_allowed_file(src, dest, files):
    if not files:
        return True
    return (src in files) or (dest in files)


def install(args):
  if os.path.exists(os.path.join(home, '.bash_profile')):
      print >> sys.stderr, ".bash_profile exists. This can cause problems. Maybe you should remove it."

  if opts.verbose:
      print >> sys.stderr, "Creating directories..."
  for (dir, perms) in dirs:
      dir_full_path = os.path.join(home, dir)
      if not os.path.exists(dir_full_path):
          if opts.verbose or opts.dry_run:
              print >> sys.stderr, "Creating directory: %s" % dir_full_path
          if not opts.dry_run:
              os.mkdir(dir_full_path)
      if not perms is None:
          os.chmod(dir_full_path, perms)
  if opts.verbose:
      print >> sys.stderr, "Installing files..."
  for (source, deployed, translate) in targets(args, installs):
      if not os.path.exists(source):
          continue
      source_mtime = os.path.getmtime(source)
      # If the file doesn't exist then don't try to check the time.
      if os.path.exists(deployed):
          deployed_mtime = os.path.getmtime(deployed)
      else:
          deployed_mtime = 0
      if not opts.force and deployed_mtime > source_mtime:
          if opts.verbose:
              print >> sys.stderr, "Skipping locally modified file %s: Use -f to override this." % source
          continue
      if translate:
          if opts.verbose or opts.verbose:
              print >> sys.stderr, "Translating and installing file: %s -> %s" % (source, deployed)
          translate_file(source, deployed, get_arch())
      else:
          if opts.verbose or opts.dry_run:
              print >> sys.stderr, "Installing file: %s -> %s" % (source, deployed)
          if not opts.dry_run:
              shutil.copy2(source, deployed)
      if not opts.dry_run:
          shutil.copystat(source, deployed)
  if opts.verbose:
      print >> sys.stderr, "Removing stale files..."
  for (source, deployed, translate) in targets(args, removals):
      if os.path.exists(deployed):
          if opts.verbose or opts.dry_run:
              print >> sys.stderr, "Removing stale file: %s" % deployed
          if not opts.dry_run:
              os.unlink(deployed)


def get_arch():
    return uname_to_arch.get(platform.uname()[0], 'UNKNOWN')


def translate_file(src, dest, arch):
    with open(src, 'r') as src_file:
        with output_sink(dest) as dest_file:
            if opts.verbose or opts.dry_run:
                print "Generated file: %s -> %s" % (src, dest)
            for line in filter_for_arch(src_file, arch):
                for expanded_line in expansion(line):
                    if opts.verbose and not opts.dry_run:
			sys.stdout.write(expanded_line)
                    dest_file.write(expanded_line)


@contextmanager
def output_sink(dest):
    if opts.dry_run:
        yield sys.stdout
    else:
       with open(dest, 'w') as f:
           yield f


has_arch = re.compile(r'^(%s):' % '|'.join(archs))


def filter_for_arch(lines, arch):
    for line in lines:
        match = has_arch.search(line)
        if match and match.group(1) != arch:
            pass
        elif match:
            yield line[len(match.group(0)):]
        else:
            yield line


def expansion(line):
    if line.startswith('GEN:'):
        yield subprocess.check_output(line[len('GEN:'):], shell=True)
    else:
        yield line


def recover(args):
  for (source, deployed, translated) in targets(args, installs):
      if os.path.exists(deployed):
          if  translated:
              if md5_digest(source) != md5_digest(deployed):
                  subprocess.call(['p4merge', deployed, source, source, source])
          else:
              shutil.copy2(deployed, source)


def diff(args):
  for (source, deployed, translate) in targets(args, installs):
    if os.path.exists(source) and not os.path.exists(deployed):
        print "File %s not deployed from %s" % (deployed, source)
    elif not os.path.exists(source) and os.path.exists(deployed):
        print "File %s not recovered from %s" % (source, deployed)
    elif os.path.exists(source) and os.path.exists(deployed):
      if md5_digest(source) != md5_digest(deployed):
        subprocess.call(['p4merge', deployed, source])


parser = optparse.OptionParser(description='install dot files')
parser.add_option('--diff', dest='action', action='store_const',
    const=diff, help='diff deployed and source dot files')
parser.add_option('--install', dest='action', action='store_const',
    const=install, help='install dot files')
parser.add_option('--recover', dest='action', action='store_const',
    const=recover, help='recover dot files from environment')
parser.add_option('--completions', dest='action', action='store_const',
    const=completions, help='show possible file path completions')
parser.add_option('-n', dest='dry_run', action='store_true', default=False,
    help='dry_run')
parser.add_option('-f', dest='force', action='store_true', default=False,
    help='force deployment')
parser.add_option('-v', dest='verbose', action='store_true', default=False,
    help='be verbose about what is happening')

if __name__ == '__main__':
    (opts, args) = parser.parse_args()
    if opts.action is None:
        opts.action = diff
    opts.files = args
    opts.action(opts)

