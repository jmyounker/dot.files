#!/usr/bin/python

import os
import re
import subprocess
import sys

default_prompt = '${debian_chroot:+($debian_chroot)}\u@\h:\[$(tput -T${TERM:-dumb} setaf 4)\]%(path)s\[$(tput -T${TERM:-dumb} sgr0)\]\$ '
proj_prompt = '${debian_chroot:+($debian_chroot)}\u@\h[\[$(tput -T${TERM:-dumb} setaf 1)\]%(proj)s:%(branch)s\[$(tput -T${TERM:-dumb} sgr0)\]]:\[$(tput -T${TERM:-dumb} setaf 4)\]%(path)s\[$(tput -T${TERM:-dumb} sgr0)\]\$ '
msg_prompt = '${debian_chroot:+($debian_chroot)}\u@\h[\[$(tput -T${TERM:-dumb} setaf 1)\]%(msg)s\[$(tput -T${TERM:-dumb} sgr0)\]]:\[$(tput -T${TERM:-dumb} setaf 4)\]%(path)s\[$(tput -T${TERM:-dumb} sgr0)\]\$ '
proj_file = "%(home)s/.proj_current"

path_condensations = [("java", "j"),
                      ("javatests", "jt"),
                      ("tests", "ts"),
                      ("test", "t"),
                      ("harness", "har"),
                      ("analytics", "anal"),
                      ("experimental", "exp"),
                      ("jyounker", "jy"),
                      ("jeff", "j"),
                      ("production", "p"),
                     ]


def log(message):
    """Appends a log message to a file. Used for debugging."""
    with open('/tmp/get_prompt.log', 'a') as logfile:
        print >> logfile, message


def set_state_expr():
    try:
        path = os.getcwd()
    except OSError, e:
        if e.errno == 2:
            prompt = msg_prompt % {'path': '?',
                                   'msg': 'DUDE! THE DIRECTORY IS GONE. WTF?'}
            return prompt_assignment(prompt)
        raise

    home = os.environ.get('HOME')
    user = os.environ.get('USER')

    cmds = []
    cmds.append(set_prompt_expr(path, home, user))
    cmds.append(set_cdpath_expr(path, home, user))
    return '; '.join(cmds)


def dir_is_available(dir_path):
    try:
        return os.path.exists(dir_path)
    except OSError:
        return False


def set_prompt_expr(path, home, user):
    return prompt_assignment(get_prompt(path, home, user))


def prompt_assignment(prompt):
    return 'PS1=\'%s\'' % prompt


def get_prompt(path, home, user):
    projroot = file_in_path(path, '.git')
    proj = ""
    if projroot:
        (_, proj) = os.path.split(projroot)
    prompt_path = condense_path(path, home, user, proj)

    if home:
        try:
            os.path.exists(home)
        except OSError, e:
            if e.errno == 2:
                return msg_prompt % {'path':prompt_path,
                                     'msg': "DUDE! CAN'T FIND HOME DIRECTORY. WTF?"}
            raise
    try:
        os.path.exists(path)
    except OSError, e:
        if e.errno == 2:
            return msg_prompt % {'path': '?',
                                 'msg': 'THE DIRECTORY %s IS GONE!' % path}
        raise

    if proj:
       try:
          output = subprocess.check_output(['/usr/bin/git', 'status', '-b', '--porcelain'])
       except:
          return proj_prompt % {'proj': proj, 'branch': '', 'path': prompt_path}

       untracked_branch = re.search("^##\s+(\S+)\n", output)
       tracked_branch = re.search("^##\s+(\S+)\.\.\.", output)
       branch_match = tracked_branch if tracked_branch else untracked_branch
       if not branch_match:
         return proj_prompt % {'proj': proj, 'branch': '', 'path': prompt_path}
       branch = branch_match.group(1)
       return proj_prompt % {'proj': proj, 'branch': branch, 'path': prompt_path}
    else:
        return default_prompt % {'path': prompt_path}


def condense_path(path, home, user, proj):
    if not path.endswith('/'):
       path = path + '/'

    path = trim_initial_path_components(path, home, user, proj)
    if not path:
      return ""

    has_leading_slash = path.startswith('/')
    if not has_leading_slash:
      path = '/' + path

    for (component, condensed) in path_condensations:
      path = path.replace("/" + component + "/", "/" + condensed + "/") 

    if not has_leading_slash:
       path = path[1:]

    if not path:
       return path

    # strip trailing slash
    return path[:-1]


def trim_initial_path_components(path, home, user, proj):
    # $HOME/baz/ -> ~/baz/
    # $HOME/ -> ~/
    if path.startswith(home + '/'):
      path = path[(len(home) + 1):]
      return "~/" + path

    return path


def write_file(filename, contents):
    try:
        f = open(filename, 'w')
        try:
            f.write(contents)
        finally:
            f.close()
    except:
        pass


def file_in_path(path, filename):
    if os.path.exists(os.path.join(path, filename)):
        return path
    (parent, base) = os.path.split(path)
    if parent == path:
        return ""
    else:
        return file_in_path(parent, filename)    


def parent_of(path, component):
    (parent, base) = os.path.split(path)
    if parent == path:
        return None
    if base == component:
        return parent
    else:
        return parent_of(parent, component)


def set_cdpath_expr(path, home, user):
    if not path.endswith('/'):
        path += '/'
    return 'export CDPATH=\'%s\'' % get_cdpath(path, home, user)


def get_cdpath(path, home, user):
    git_home = file_in_path(path, '.git')
    if not git_home:
       return ':'.join([".", home])
    return ':'.join([".", git_home, home] + dev_paths(path, user, os.path.basename(git_home)))


# Currently this is still the skeleton from when I worked at Google.  It will need to be updated when
# I begin doing big projects again.
def dev_paths(path, user, proj):
    # A set of relative paths
    devpaths = []

    git5_component = 'git5'
    if ('/%s/' % git5_component) in path:
        git5_path = os.path.join(parent_of(path, git5_component),
                                 git5_component)
        return [os.path.join(git5_path, p) for p in devpaths]

    return []


if __name__ == '__main__':
    sys.stdout.write(set_state_expr())
