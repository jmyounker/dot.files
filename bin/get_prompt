#!/usr/bin/python

import os
import re
import subprocess
import sys


default_prompt = '${debian_chroot:+($debian_chroot)}\u@\h:\[$(tput -T${TERM:-dumb} setaf 4)\]%(path)s\[$(tput -T${TERM:-dumb} sgr0)\]\$ '
proj_prompt = '${debian_chroot:+($debian_chroot)}\u@\h[\[$(tput -T${TERM:-dumb} setaf 1)\]%(proj)s\[$(tput -T${TERM:-dumb} sgr0)\]]:\[$(tput -T${TERM:-dumb} setaf 4)\]%(path)s\[$(tput -T${TERM:-dumb} sgr0)\]\$ '
msg_prompt = '${debian_chroot:+($debian_chroot)}\u@\h[\[$(tput -T${TERM:-dumb} setaf 1)\]%(msg)s\[$(tput -T${TERM:-dumb} sgr0)\]]:\[$(tput -T${TERM:-dumb} setaf 4)\]%(path)s\[$(tput -T${TERM:-dumb} sgr0)\]\$ '
proj_file = "%(home)s/.proj_current"

path_condensations = [("java", "j"),
                      ("javatests", "jt"),
                      ("tests", "ts"),
                      ("test", "t"),
                      ("harness", "har"),
                      ("analytics", "anal"),
                      ("experimental", "exp"),
                      ("jyounker", "jy"),
                      ("jeff", "j"),
                      ("production", "p"),
                      ("Python Testing for Dummies", "PTfD"),
                      # SoundCloud abbreviations
                      ("github.com", "gh"),
                      ("soundcloud", "sc"),
                      ("soundcloud-cookbooks", "sc-cb"),
                      ("harpoon", "hpn"),
                      ("harpoon-agent", "hpn-agnt"),
                      ("harpoon-container", "hpn-cnt"),
                      ("harpoon-configstore", "hpn-cfgstore"),
                      ("harpoon-internal", "hpn-int"),
                      ("harpoon-scheduler", "hpn-schd"),
                      ("harpoon-supervisor", "hpn-spv"),
		      # SavingGlobal abbreviations
                      ("dev", "d"),
                      ("svn", "s"),
                      ("git", "g"),
                      ("opsys", "o"),
                      ("trunk", "t"),
                      ("branches", "b"),
                     ]

prefix_transforms = [(os.environ.get('HOME') + '/', '~/'),
                     # SoundCloud VMWare shared directory fixes
                     ("/mnt/hgfs/dev/", "~/dev/"),
                     ("/mnt/hgfs/repos/", "~/repos/"),
                    ]

def log(message):
    """Appends a log message to a file. Used for debugging."""
    with open('/tmp/get_prompt.log', 'a') as logfile:
        print >> logfile, message


def set_state_expr():
    try:
        path = os.getcwd()
    except OSError, e:
        if e.errno == 2:
            prompt = msg_prompt % {'path': '?',
                                   'msg': 'DUDE! THE DIRECTORY IS GONE. WTF?'}
            return prompt_assignment(prompt)
        raise

    home = os.environ.get('HOME')
    user = os.environ.get('USER')

    cmds = []
    cmds.append(set_prompt_expr(path, home, user))
    cmds.append(set_cdpath_expr(path, home, user))
    return '; '.join(cmds)


def dir_is_available(dir_path):
    try:
        return os.path.exists(dir_path)
    except OSError:
        return False


def set_prompt_expr(path, home, user):
    return prompt_assignment(get_prompt(path, home, user))


def prompt_assignment(prompt):
    return 'PS1=\'%s\'' % prompt


def get_proj_name(proj_config):
    with open(proj_config) as f:
        proj_entry = eval(f.read())
    if 'name' in proj_entry:
        return proj_entry['name']
    else:
        return os.path.basename(os.path.dirname(proj_config))


def get_prompt(path, home, user):
    proj_root = file_in_path(path, '.projrc')
    proj = ""
    if proj_root:
        proj_config = os.path.join(proj_root, '.projrc')
        try:
            proj = get_proj_name(proj_config)
        except:
            proj = os.path.basename(proj_root)
    prompt_path = condense_path(path, home, user, proj)

    if home:
        try:
            os.path.exists(home)
        except OSError, e:
            if e.errno == 2:
                return msg_prompt % {'path':prompt_path,
                                     'msg': "DUDE! CAN'T FIND HOME DIRECTORY. WTF?"}
            raise
    try:
        os.path.exists(path)
    except OSError, e:
        if e.errno == 2:
            return msg_prompt % {'path': '?',
                                 'msg': 'THE DIRECTORY %s IS GONE!' % path}
        raise

    if proj:
        # This line allows the prompt to work while inside .git directory trees.
        if '/.git/' in path + '/':
            return proj_prompt % {'proj': proj, 'path': prompt_path}
        try:
            output = subprocess.check_output(['/usr/bin/git', 'status', '-b', '--porcelain'],
                stderr=subprocess.STDOUT)
        except:
            return proj_prompt % {'proj': proj, 'path': prompt_path}

        untracked_branch = re.search("^##\s+(\S+)\n", output)
        tracked_branch = re.search("^##\s+(\S+)\.\.\.", output)
        branch_match = tracked_branch if tracked_branch else untracked_branch
        proj_tag = proj
        if branch_match:
            branch = branch_match.group(1)
            proj_tag += ':%s' % branch
        virtual_env = os.environ.get('VIRTUAL_ENV')
        if virtual_env:
            proj_tag  += ',%s' % os.path.basename(virtual_env)
        return proj_prompt % {'proj': proj_tag, 'path': prompt_path}
    else:
        return default_prompt % {'path': prompt_path}


def condense_path(path, home, user, proj):
    if not path.endswith('/'):
        path = path + '/'

    path = transform_prefix(path, prefix_transforms)
    if not path:
        return ""

    # The replacement logic depends upon starting with a slash, so we add one if it is not present. This
    # will be removed later.
    has_leading_slash = path.startswith('/')
    if not has_leading_slash:
        path = '/' + path

    for (component, condensed) in path_condensations:
        path = path.replace("/" + component + "/", "/" + condensed + "/")

    # Trim the leading slash if we added it.
    if not has_leading_slash:
        path = path[1:]

    if not path:
        return path

    # strip trailing slash
    return path[:-1]


def transform_prefix(path, prefix_transforms):
    """Replaces the first prefix it finds."""
    for (prefix, transform) in prefix_transforms:
        if path.startswith(prefix):
            path = path[(len(prefix)):]
            return transform + path
    return path


def write_file(filename, contents):
    try:
        f = open(filename, 'w')
        try:
            f.write(contents)
        finally:
            f.close()
    except:
        pass


def file_in_path(path, filename):
    if os.path.exists(os.path.join(path, filename)):
        return path
    (parent, base) = os.path.split(path)
    if parent == path:
        return ""
    else:
        return file_in_path(parent, filename)    


def parent_of(path, component):
    (parent, base) = os.path.split(path)
    if parent == path:
        return None
    if base == component:
        return parent
    else:
        return parent_of(parent, component)


def set_cdpath_expr(path, home, user):
    if not path.endswith('/'):
        path += '/'
    return 'export CDPATH=\'%s\'' % get_cdpath(path, home, user)


def get_cdpath(path, home, user):
    git_home = file_in_path(path, '.git')
    if not git_home:
        return ':'.join([".", home])
    return ':'.join([".", git_home, home] + dev_paths(path, user, os.path.basename(git_home)))


# Currently this is still the skeleton from when I worked at Google.  It will need to be updated when
# I begin doing big projects again.
def dev_paths(path, user, proj):
    # A set of relative paths
    partial_dev_paths = []

    git5_component = 'git5'
    if ('/%s/' % git5_component) in path:
        git5_path = os.path.join(parent_of(path, git5_component),
                                 git5_component)
        return [os.path.join(git5_path, p) for p in partial_dev_paths]

    return []

if __name__ == '__main__':
    sys.stdout.write(set_state_expr())
